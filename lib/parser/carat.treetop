module Carat
  grammar Language
    # A program is the top-level node, containing just a block of code
    rule program
      block
    end
    
    # A block is 1 or more expressions separated by terminators
    rule block
      first:expression rest:(terminator expression)* terminator? <Block> /
      '' <EmptyBlock>
    end
    
    # An expression is the basic 'thing'
    rule expression
      class_definition /
      method_definition /
      assignment /
      literal /
      method_call /
      instance_variable /
      local_variable_or_method_call
    end
    
    rule class_definition
      'class' space constant definition_body <ClassDefinition>
    end
    
    rule method_definition
      'def' space identifier definition_body <MethodDefinition>
    end
    
    rule definition_body
      multiline_space block 'end'
    end
    
    rule assignment
      variable space? '=' space? expression <Assignment>
    end
    
    # A literal object, e.g. a number, string, true, false, etc
    rule literal
      number / string / boolean / nil
    end
    
    # A method call. This is for when we definitely know it's a method call, so simply "foo" is not
    # matched as that may be a local variable or a method call.
    rule method_call
      receiver '.' identifier arguments:arguments? <MethodCall> / # Explicit receiver
      receiver:nothing identifier arguments <MethodCall>          # Implicit receiver
    end
    
    # The receiver of a method call
    rule receiver
      constant / variable
    end
    
    # Arguments - this is when there are definitely arguments but they are possibly empty (i.e. an
    # empty pair of parentheses). If there is simply an empty string (i.e. an empty list of
    # arguments *not* surrounded by parentheses) these are not matched - this special case is dealt
    # with by the local_variable_or_method_call rule
    rule arguments
      '(' multiline_space? ')' <EmptyArgumentList> /
      '(' multiline_space? first:expression rest:(multiline_space? ',' multiline_space? expression)* multiline_space? ')' <ArgumentList> /
      space first:expression rest:(space? ',' multiline_space? expression)* <ArgumentList>
    end
    
    # A local or instance variable
    rule variable
      local_variable / instance_variable
    end
    
    # This is the same as local_variable except that it may also be a method call with an implicit
    # receiver, no parentheses and no arguments. This ambiguity has to be resolved at runtime.
    rule local_variable_or_method_call
      local_identifier <LocalVariableOrMethodCall>
    end
    
    # A local variable when we know it is definitely a variable (not a method)
    rule local_variable
      local_identifier <LocalVariable>
    end
    
    rule instance_variable
      '@' identifier <InstanceVariable>
    end
    
    rule keyword
      'class' / 'def' / 'end'
    end
    
    # A general identifier must not start with a number
    rule identifier
      [a-zA-Z_] [a-zA-Z0-9_]*
    end
    
    # A local identifier must start with an underscore or lowercase letter, and must not conflict
    # with a keyword
    rule local_identifier
      !keyword [a-z_] [a-zA-Z0-9_]*
    end
    
    # A constant must start with a capital letter
    rule constant
      [A-Z] [a-zA-Z0-9_]* <Constant>
    end
    
    rule number
      [0-9]+ <Integer>
    end
    
    rule string
      "'" value:[^\']* "'" <String> /
      '"' value:[^\"]* '"' <String>
    end
    
    rule boolean
      'true' <True> / 'false' <False>
    end
    
    rule nil
      'nil' <Nil>
    end
    
    # A terminator signifies the end of a statement. It can be a newline or a semicolon, followed
    # by any amount of space
    rule terminator
      ("\n" / ";") multiline_space?
    end
    
    rule space
      [ \t]+
    end
    
    rule multiline_space
      [ \t\n\r]+
    end
    
    # This rule is useful because it has a to_ast method which returns nil
    rule nothing
      '' <Nothing>
    end
  end
end
