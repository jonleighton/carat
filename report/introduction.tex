\section{Introduction}

\subsection{Objectives}

My basic project idea was to produce some sort of programming language implementation. I didn't think it would be practical or useful to attempt to design a language from scratch; this can take years of careful thought in order to produce interesting results.

I was already very familiar with Ruby\footnote{\url{http://www.ruby-lang.org/en/}}, which is a dynamic, high-level, object oriented programming language. So I decided to implement a language similar to Ruby, using Ruby to write the implementation itself.

My language would seek to ask the question: \textit{what is the essence of Ruby?} I aimed to implement only the features which I considered essential to the nature of Ruby. In doing so, I would also carefully consider whether there were any changes or improvements which could be made to increase or refine its expressive power. I would do this through manipulating both the syntax and semantics of the language.

Many real-world language implementations are very complex due to heavy optimisation and the necessity of dealing with the myriad practical problems a production-quality programming language requires. They also tend to be written in lower level languages such as C or C++, for reasons of speed. Unfortunately this can make them difficult to read and understand. Without the burden of these requirements, my second objective was to produce a clean, well-written, concise implementation which neatly expressed the semantics of the language.

\subsection{Overview of Report}

It's fun to think up quirky names for projects, so I have chosen to name my language ``Carat" (the carat is a measure of purity in gold alloys).

This report starts by presenting a very basic example program and giving a detailed overview of how it is executed. Many of the key language features are discussed through this, but some which deserve further explanation are presented in the following section. The testing strategy is then explained, before a concluding section which compares Carat to Ruby and presents further ideas for the project.

\subsection{Definitions}

\begin{description}
	\item[Implementation language] refers to the environment in which the implementation is written: the collection of Ruby code which forms the project
	\item[Target language] refers to the environment of the ``Carat" language actually being implemented
	\item[AST] is an acronym for ``Abstract Syntax Tree"
\end{description}

\subsection{Notation and Ruby syntax}

\begin{itemize}
  \item Classes have capitalised names and are shown by grey boxes in diagrams: \\
    \begin{tikzpicture}
    \node[class] {ExpressionList};
    \end{tikzpicture}
  
  \item Modules have capitalised names and are shown by green boxes in diagrams: \\
    \begin{tikzpicture}
    \node[module] {Kernel};
    \end{tikzpicture}
  
  \item Singleton classes have the name of their singleton with an apostrophe appended. They are shown by red boxes in digrams: \\
    \begin{tikzpicture}
    \node[sclass] {Apple'};
    \end{tikzpicture}
  
  \item Other objects have lower case names and are shown by blue boxes in diagrams: \\
    \begin{tikzpicture}
    \node[object] {apple};
    \end{tikzpicture}
  
  \item \code{Foo#bar} refers to the instance method \code{bar} of the class \code{Foo}
  
  \item \code{Foo.baz} refers to the class method \code{baz} of the class \code{Foo}
  
  \item \code{foo} refers to a local variable named \code{foo} (or a method)
  
  \item \code{@foo} refers to an instance variable named \code{foo}
  
  \item Blocks are specified in method calls either using two syntaxes:
  \begin{lstlisting}
  foo do |arglist|
    ...
  end
  
  # or
  
  foo { |arglist| ... }
  \end{lstlisting}
  
  \item \code{&foo} is used to pass a block to a method call, or receive one in a method definition
\end{itemize}
