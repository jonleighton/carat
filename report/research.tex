\section{Research}

I will begin by researching current interpreters and parsers either written in Ruby, or written to interpret Ruby. After this I hope to be able to identify a sensible approach to my own interpreter.

\subsection{Heist: A Scheme interpreter in Ruby}

Scheme is a dialect of the Lisp family of programming languages. This is an example of a Scheme program which defines the function \texttt{abs}, which returns the absolute value of a number:

\begin{lstlisting}[language=]
(define (abs x)
  (if (negative? x)
      (- x)
      x))
\end{lstlisting}

Heist (\url{http://github.com/jcoglan/heist}) is an interpreter for Scheme written purely in Ruby. According to its author:

\begin{quote}
It provides an executable for running Scheme code directly, and also allows the interpreter to be easily embedded in, and extended using, Ruby applications. It nominally targets R5RS, though is likely to be more liberal than other implementations.
\end{quote}

I have chosen to study Heist because it is a small and well-written example of an interpreter in Ruby. The code is very well commented, which will help me to understand it.

\subsubsection{The parser}
\label{sec:heist-parser}

Heist uses a parser generator called Treetop (\url{http://treetop.rubyforge.org/}). Treetop is itself written in Ruby, and is capable of generating parsers which are also written in Ruby.

Treetop uses a form of grammar called Parsing Expression Grammars (\gls{PEG}s). [Insert explanation of PEGs from \url{http://pdos.csail.mit.edu/~baford/packrat/popl04/}. Here is the abstract:

\begin{quote}
For decades we have been using Chomsky's generative system of grammars, particularly context-free grammars (CFGs) and regular expressions (REs), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difficult both to express and to parse machine-oriented languages using CFGs. Parsing Expression Grammars (PEGs) provide an alternative, recognition-based formal foundation for describing machine-oriented syntax, which solves the ambiguity problem by not introducing ambiguity in the first place. Where CFGs express nondeterministic choice between alternatives, PEGs instead use prioritized choice. PEGs address frequently felt expressiveness limitations of CFGs and REs, simplifying syntax definitions and making it unnecessary to separate their lexical and hierarchical components. A linear-time parser can be built for any PEG, avoiding both the complexity and fickleness of LR parsers and the inefficiency of generalized CFG parsing. While PEGs provide a rich set of operators for constructing grammars, they are reducible to two minimal recognition schemas developed around 1970, TS/TDPL and gTS/GTDPL, which are here proven equivalent in effective recognition power.]
\end{quote}

An example of a grammar for simple arithmetic, written in Treetop is as follows (this is taken from the Treetop website):

\begin{lstlisting}[language=]
grammar Arithmetic
  rule additive
    multitive '+' additive / multitive
  end

  rule multitive
    primary '*' multitive / primary
  end

  rule primary
    '(' additive ')' / number
  end

  rule number
    [1-9] [0-9]*
  end
end
\end{lstlisting}

We can define methods on nodes in the parse tree in order to give them some meaning, for example:

\begin{lstlisting}[language=]
grammar Arithmetic
  rule additive
    multitive '+' additive {
      def value
        multitive.value + additive.value
      end
    }
    /
    multitive
  end
  
  # ...
end
\end{lstlisting}

It is also possible to take the code out into a separate class defined in Ruby like so:

\begin{lstlisting}[language=]
grammar Arithmetic
  rule additive
    multitive '+' additive <AdditiveNode>
    /
    multitive
  end
  
  # ...
end
\end{lstlisting}

\begin{lstlisting}
class AdditiveNode < Treetop::Runtime::SyntaxNode
  def value
    multitive.value + additive.value
  end
end
\end{lstlisting}

This is what Heist does. There is a file \texttt{scheme.tt} which defines the grammar and associated node classes with terminals and non-terminals where relevant. Then there is a separate file \texttt{nodes.rb} which defines the various node classes. Each node has an \texttt{eval} method which turns the parse tree into a object-oriented representation of the abstract syntax.

\subsubsection{The runtime}

The syntax of Scheme/Lisp, in essense, is just a hundful of literals (booleans, numbers, identifiers, etc) and a way of writing lists which contain these literals. Additionally identifiers can represent functions, which can be called by applying arguments to them. But the syntax for this is just a list where the first item is the name of the function, and the remaining items are arguments.

Given this ``purity" in the syntax, Heist chooses to keep its parser to a bare minimum. For example, function definitions are not distinguished by the parser. Instead, a function definition is simply an application of the function \texttt{define}.

The function \texttt{define} is constructed as a `primitive'. Primitives are blocks of code in the meta language which can be executed by code in the object language, and this is how a large part of Heist's functionality is defined. There are also a number of library functions which are written in Scheme itself, as they don't require any access to the abstract syntax tree.

Heist has four key classes which it uses to evaluate the abstract syntax tree once it has been constructed. These are:

\begin{description}
	\item[Runtime] which has overall responsibility for maintaining the stack and the top-level scope
	\item[Stack] which processes frames when they are pushed onto the stack
	\item[Scope] which is essentially a symbol table mapping identifiers to values
	\item[Frame] which binds a given scope to an expression. The scope will then be used when the expression is evaluated.
\end{description}

A high level overview of how Heist executes a program is as follows:

\begin{enumerate}
	\item Parse the code and generate an abstract syntax tree of \texttt{Expression}s
	\item Instantiate a \texttt{Runtime} object. Create a \texttt{Stack}. Create a top-level \texttt{Scope} and add the primitive, syntax and library functions to it. Create a user-level \texttt{Scope} within which the program will be executed.
	\item Create a \texttt{Frame} binding the user-level \texttt{Scope} to the top-level \texttt{Expression} of the AST, and push this onto the \texttt{Stack}
	\item The stack then starts ``processing" its contents, adding and removing frames where relevant
\end{enumerate}

Additionally Heist has support for turning various features on an off, such as lazy evaluation and continuations. If lazy evaluation is used, or continuations are not used, then Heist uses a stackless `stack' instead, which is faster.

\subsection{S-expressions}
\label{sec:sexps}

S-expressions (\gls{sexp}s) are simple data structures which can be used to represent abstract syntax trees. They are lists of symbols, literals and other lists. In fact, all Lisp programs can be considered to be sexps, and this is what makes Heist's parser so simple - all it does is parse sexps.

Sexps are an attractive way of representing an abstract syntax tree because they are very simple and human-readable. This contrasts with the alternative of building up a hierarchy of objects to represent the \gls{AST}, which require some sort of alternative transformation in order to be presented in a human-readable form.

Sexps can be represented quite simply in Ruby by using arrays and symbols. For example, the following Ruby code:

\begin{lstlisting}
def hello(who)
  "hello " + who
end
hello("world")
\end{lstlisting}

might be represented as the following sexp in Ruby syntax (literals starting with `\texttt{:}' are symbols):

\begin{lstlisting}
[:defn, :hello,
  [:args, :who],
  [:scope,
    [:apply,
      :'+',
      [:string, "hello "],
      [:variable, :who]]]]
[:apply, :hello, :main, [:string, "world"]]
\end{lstlisting}

It is easy to see that a simple strategy for evaluating such sexps would be to write a recursive \texttt{eval} method which performs case analysis.

Using Treetop, it would be possible to generate these sexps by writing methods on nodes in the parse tree, as explained in section \ref{sec:heist-parser}.

It is worth noting that there is a Ruby-in-Ruby parser which generates sexps already, called ruby\_parser (\url{http://parsetree.rubyforge.org/}).
 ruby\_parser uses a parser generator called racc, which is similar to yacc, but generates Ruby code instead of C. I could potentially use this parser in my project and just implement the semantics of the language, but I choose not to because:

\begin{enumerate}
	\item ruby\_parser is a direct port to racc of Ruby's yacc grammar, and so it features exactly the same grammar. I would like to explore the process of building my own grammar from scratch, and the decisions that involves.
	\item racc is in fact written partly in C. Treetop is written purely in Ruby, which appeals to the desire for ``purity" in my implementation.
\end{enumerate}

\subsection{Rubinius}
\label{sec:rubinius}

Rubinius (\url{http://rubini.us/}) is an implementation of Ruby. It uses a C++ virtual machine (VM) which executes bytecode.

All of the ``core" classes (such as \texttt{Object}, \texttt{Class}, \texttt{Array}, \texttt{String}, etc - Rubinius calls these the `kernel') are implemented in Ruby. When necessary, methods can be linked to ``primitives" which are implemented by the VM - this is specifically for implementing features which cannot be expressed in Ruby, such as input/output operations, and allocating space for basic object types.

The compiler which translates Ruby code to Rubinius bytecode is also written in Ruby. Rubinius is able to have so much of its source in Ruby by relying on the presence of a Ruby implementation on the machine which compiles Rubinius. When Rubinius is compiled all the Ruby code is converted to bytecode which can be run directly on the \gls{VM}.

In order to keep the complexity down, I am initially going to want to implement my own kernel classes. But it's worth bearing Rubinius in mind for the future because I could potentially re-use a lot of its kernel classes and just implement my own primitives as necessary, saving a lot of work.

Rubinius may also be useful to study if particular questions arise about how to implement specifics features; although it is quite complex, it will certainly be easier to understand than \gls{MRI}, which is written purely in C.

\subsection{RubySpec}

One thing which has come out of the development of Rubinius (see section \ref{sec:rubinius}) is a project called RubySpec (\url{http://rubyspec.org/}). RubySpec's aim is to write a complete, executable specification for Ruby. It uses a simple test framework called mspec, which is specifically written to use a minimal subset of language features. The idea is that Ruby implementors can start writing their implementation and get it to the point where it can run mspec at a fairly early stage.

It would be good to be able to run mspec on my own implementation as using RubySpec will save me a lot of effort writing my own tests and attempting to identify the various nuances of the language. RubySpec will also be a significantly easier way to find out the exact semantics of a given piece of code than trawling through the C source code of \gls{MRI}.
