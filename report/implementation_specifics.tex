\section{Implementation Specifics}

In this section I give further explanation of various specific details in the interpreter.

\subsection{Object creation}

Objects are created from classes. When a class is defined, it is added to the \code{constants} hash. Suppose we have a class \code{Candle}. An instance is created by looking up the \code{Candle} constant and calling its \code{new} method:

\begin{lstlisting}
candle = Candle.new
\end{lstlisting}

The \code{new} method (in \path{kernel/class.carat}) allocates space for the object, runs its \code{initialize} method and then returns it:

\begin{lstlisting}
def new(*args, &block)
  object = self.allocate
  object.initialize(*args, &block)
  object
end
\end{lstlisting}

The \code{allocate} method calls use a primitive to create an \code{ObjectInstance} in the implementation language. By default, \code{Object#initialize} does nothing, but this can obviously be changed in other classes.

\subsection{Method argument patterns and argument lists}

An \defn{argument pattern} is used when defining a method; it specifies what assignments should be made from the arguments when the method is called. A \defn{argument list} is used when calling a method; it specifies the arguments which should be passed to the call.

\subsubsection{Argument pattern syntax}

An argument pattern is made up of a number of items separated by a comma. Each item contains an \defn{assignee} which receives the argument value. An assignee can be a local variable, instance variable, or an \defn{assignment method name}. If the class has a method \code{colour=}, then another of its methods could have \code{self.colour} as an assignee in the argument pattern; this would cause the \code{colour=} method to be used when assigning the arguments.

There are three types of argument pattern item:

\begin{enumerate}
  \item The \defn{normal} type is just an assignee, optionally followed by an `=' and an expression giving a default value for the item. If a default is given, the item is optional. All mandatory items must come first, followed by optional ones.
  
  \item The \defn{splat} type is signified by an `*' before the assignee. This is used to condense multiple arguments into a single array which is assigned to the assignee. There can only be one splat, otherwise it would be ambigious how the arguments should be split. The splat can appear before the end of the argument pattern; it will only receive the arguments which are ``left over" after assigning the items before and after the it.
  
  \item The \defn{block pass} type is signified by an `\&' before the assignee. If a block is given in the method call, it is assigned to the assignee. There can only be one block pass and it must appear as the very last item.
\end{enumerate}

These are some example argument patterns:

\begin{lstlisting}
def foo(a, b = 5) ...
def foo(@a, *self.b) ...
def foo(*a, b = 2, &c) ...
\end{lstlisting}

\subsubsection{Argument list syntax}

An argument list is also made up of a number of items separated by a comma. There are four types:

\begin{enumerate}
  \item The \defn{normal} type is just an expression which gives a single value
  \item The \defn{splat} type is signified by an `*' before an expression. The expression is evaluated and converted to an array. Each value of the array becomes a separate argument value. There can be any number of splats in an argument list.
  \item The \defn{block pass} type is signified by an `\&' before an expression. The expression is evaluated and converted to a lambda, which is then used as the block in the method call. There can only be one block pass item and it must be at the end.
  \item The \defn{block} type is signified by a literal block using either braces or \code{do} \code{...} \code{end}. The block is used to create a lambda, which is then used as the block in the method call. There can only be one block item and it must be at the end.
\end{enumerate}

There can only be one block in a method call, so the block pass and block item types cannot both be used in the same argument list.

These are some example argument lists:

\begin{lstlisting}
foo(4 + 2, *x.y.z, &addfour)
foo("Goodbye", "Cruel") { |world| world + world }
\end{lstlisting}

\subsubsection{Argument evaluation and assignment}

Argument lists are represented by the \code{ArgumentList} AST node which contains a number of \code{Argument}\-\code{List}\-\code{::}\-\code{Item} nodes. When evaluated, the argument list builds up a \code{Call::Arguments} object which contains a number of values and optionally a block.

Argument patterns are represented by the \code{ArgumentPattern} AST node which contains a number of \code{ArgumentPattern::Item} nodes. \code{ArgumentPattern} has an \code{assign} method which is used to assign a list of arguments according to the pattern.

The argument pattern first checks whether it has been provided with a suitable number of arguments. To do this, it calculates an \defn{arity}, which is a range from the minimum arity to the maximum arity. It then checks whether the argument length is within this range.

Each argument pattern item also has a minimum arity and maximum arity. For splat and block pass items, the minimum is 0. For normal items, the minimum is 0 if there is a default value and 1 otherwise. The maximum arity is âˆž for a splat, 0 for a block pass and 1 otherwise. (Block passes are not considered part of the arity because they are not assigned `normal' argument values.)

The minimum and maximum arities for the whole argument pattern are just the sums of the minimum and maximum arities of each of the items.

Once the arity has been checked, the \code{assign} operation just works along the list of argument pattern items from left to right, taking the relevant number of values from the front of the list of argument values and making the assignment.

\subsection{Blocks, lambdas and yield}

\subsubsection{Lambda creation}

Lambdas are returned by the \code{Kernel#lambda} method (which is an alias for \code{Lambda.new}):

\begin{lstlisting}
lambda { |x| x + x }.call(2) # => 4
\end{lstlisting}

The literal block is parsed as an item in the argument list and the item's expression is a \code{Block} AST node. When a \code{Block} node is a evalauted, it returns a \code{Lambda} object. So \code{lambda} does not actually \textit{create} the lambda; it is created when the arguments are evaluated, and then just returned.

\subsubsection{Calling lambdas}

Lambdas are called using their \code{call} method (which uses a primitive), as seen above. A \code{Call} object is created and then sent, in a similar way to method calls. The main difference is the scope used. Lambdas act as \defn{closures}, which means that the variables defined in the scope where the lambda was created are available and can be changed when it is called.

To support this, scopes can have a \defn{parent}, and can be \defn{extended} to create a new scope with the previous scope as the parent. When a symbol is looked up, the symbol tables of the scope and all ancestor scopes are searched in bottom up order.

When a lambda is created, the current scope is stored. When called, the lambda will extend the stored scope and use that as the scope of the call. This means that any \textit{new} variables inside the lambda remain local, but any variables referenced which were defined outside the lambda are changed in the relevant parent scope, and so their values remain different after the call has finished. For example:

\begin{lstlisting}
a = 4
lambda do
  a += 1
  b = 3
end.call
a # => 5
b # => undefined variable or method
\end{lstlisting}

\subsubsection{Yield}

Scopes can optionally have a \defn{current block}. If a block is given in the argument list of a method call, it is assigned as the block of the scope within which the call is evaluated.

Within methods, \code{Kernel#yield} can be used to call the current block. For example:

\begin{lstlisting}
def foo
  yield 8
end

foo { |i| i + 1 } # => 9
\end{lstlisting}

The \code{yield} primitive does this by getting the block in the caller scope of the call to yield and then calling it, passing on any arguments.

\subsection{Return}

\code{Call} objects have a \defn{return continuation} which:

\begin{enumerate}
  \item Pops the call's frame from the stack
  \item Runs the call's continuation, passing the result of the call
\end{enumerate}

Usually the return continuation runs after the body of the call has been evaluated completely. However, if \code{Kernel#return} is called within the method body, the return continuation is run immediately (passing the argument of \code{return} as the result, or \code{nil}). The \code{return} primitive:

\begin{enumerate}
  \item Pops the top frame from the stack, which contains the call to \code{Kernel#return}
  \item `Unwinds' the stack, popping frames until a frame which contains a call is at the top
  \item Runs the current call's continuation; the current call is now the call being returned from, and its return continuation will remove it from the stack
\end{enumerate}

\subsection{Exceptions}


