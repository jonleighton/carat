\section{Implementation Overview}

In this section, I consider the execution of the following program:

\begin{lstlisting}
puts "Goodbye Cruel World"
\end{lstlisting}

This example is deliberately minimal. In explaining it, I will focus on the overall design of the interpreter, rather than the implementation of specific language features.

\subsection{Code layout}

The interpreter code is organised into the following directory structure:

\begin{dirlist}
  \item \textbf{lib/}
    \begin{dirlist}
      \item \textbf{ast/} - AST nodes
      \item \textbf{data/} - Classes representing objects in the target language
      \item \textbf{kernel/} - Core classes in the target language
      \item \textbf{parser/} - The parser and associated code
      \item \textbf{runtime/} - Classes representing run time state and behaviour
      \item \textbf{carat.rb} - Responsible for loading the interpreter
    \end{dirlist}
\end{dirlist}

\subsection{Parsing}

The first step is to parse the source code and convert it into an AST. This is done by the \code{Carat::}\-\code{Language}\-\code{Parser} class, which is largely produced by the parser generator, Treetop\footnote{\url{http://treetop.rubyforge.org/}}.

I chose Treetop because its grammar format is intuitive. It uses Parsing Expression Grammars\footnote{\url{http://pdos.csail.mit.edu/~baford/packrat/}} which avoid the need to write a separate tokeniser. Here is an excerpt from the grammar (in \path{parser/language.treetop}), defining the syntax for a while loop:

\begin{lstlisting}[language=treetop]
rule while_expression
  'while' space condition:expression space? terminator
  contents:expression_list
  'end' <WhileExpression>
end
\end{lstlisting}

Characters in single quotes are matched literally. The other items are references to rules. Names before a colon apply a label. The question mark in ``\code{space?}" makes that rule optional.

The parser produces a parse tree. Each node has a \code{to_ast} method, which recursively converts it to an AST. In the above example, \code{<WhileExpression>} specifies the name of a class for the node, which is defined in \path{parser/nodes.rb}:

\begin{lstlisting}
class WhileExpression < Treetop::Runtime::SyntaxNode
  def to_ast
    Carat::AST::While.new(location, condition.to_ast, contents.to_ast)
  end
end
\end{lstlisting}

This is a simple example; more complex nodes may not map directly to an AST, and may need to do additional syntax checking.

\subsection{Abstract Syntax Tree}

Each AST node has a number of children (other nodes) and properties (static data). It also has an \code{eval} method which is discussed later. For example, the node for a method call is defined as:

\begin{lstlisting}
class MethodCall < Node
  child :receiver
  property :name
  child :arguments
end
\end{lstlisting}

These attributes can be used to print an AST as text. The example program's AST is printed as:

\begin{lstlisting}[language=]
ExpressionList:
  MethodCall[:puts]:
    receiver:
      nil
    arguments:
      ArgumentList:
        ArgumentList::Item[:normal]:
          expression:
            String["Goodbye Cruel World"]
\end{lstlisting}

This can be read as an expression list with one item: a call to the method `puts'. The object receiving the call is not explicitly given. The argument list contains one item, which is the literal string ``Goodbye Cruel World".

\subsection{The Runtime}

\code{Carat::Runtime} is the starting point for running a program. When initialised it:

\begin{enumerate}
  \item Creates an empty \defn{stack of stacks}. When a program is being executed, its state is stored by a stack. But a program can load additional files which need to execute with their own stack, before returning to the previous stack. For this we need a stack of stacks.
  \item Creates an empty hash for \defn{constants}. Constants are globally defined, so are not stored on a stack.
  \item Creates an empty list of \defn{loaded files} to prevent the same file being loaded more than once.
  \item Runs the \code{KernelLoader} which sets up the core classes in the target language (\code{Object}, \code{Class}, \code{Array}, \code{String}, ...). While some code is needed in the implementation language, most of this is done by interpreting class definitions written in the target language. To optimise this, the parsing is done ahead-of-time and the AST nodes are stored as binary data in files. These files are then loaded directly.
\end{enumerate}

\subsection{The Stack}

Whenever the \defn{stack} is referred to, this is the stack at the top of the stack of stacks. The stack contains one or more \defn{frames}. Frames can contain:

\begin{enumerate}
  \item A \defn{scope}, which stores the values of local variables
  \item A \defn{call}, which represents a method or lambda call
  \item A \defn{failure continuation}, which describes what to do when an exception is raised
\end{enumerate}

All of these values are optional because they can all change independently of each other during program execution. But in practice a frame should have at least one or it will be quite useless.

The ``current scope", ``current call" or ``current failure continuation" refers to whichever value is in a frame closest to the top of the stack.

\subsection{The Object Model}
\label{sec:object_model}

Carat follows Ruby's object model closely. Everything is an object, and all objects are represented by the class \code{Carat::Data::ObjectInstance} in the implementation language. There are various other classes which implement behaviour for certain types of objects, but all are subclasses of \code{ObjectInstance}. Through this, the inheritance hierarchy of data objects in the implementation language mirrors that of objects in the target language (figure \ref{fig:data_object_hierarchy}).

\begin{figure}
\begin{center}
\begin{tikzpicture}
[
  every node/.style={class},
  level 1/.style={sibling distance=40mm},
  level 3/.style={sibling distance=30mm},
  level 4/.style={level distance=10mm}
]
\node {ObjectInstance}
  child { node {ModuleInstance}
    child { node {ClassInstance}
      child { node {ObjectClass}
        child { node {ModuleClass}
          child { node {ClassClass}
            child { node {SingletonClassClass} }
          }
        }
      }
      child { node [multiline node] {ArrayClass, \\ StringClass, \\ FixnumClass, \\ ...} }
      child { node [multiline node] {IncludeClass- \\ Instance} }
      child { node [multiline node] {SingletonClass- \\ Instance} }
    }
  }
  child { node [multiline node] {ArrayInstance, \\ StringInstance, \\ FixnumInstance, \\ ...} };
\end{tikzpicture}
\caption{Inheritance hierarchy of \movingcode{Carat::Data} classes}
\label{fig:data_object_hierarchy}
\end{center}
\end{figure}

\subsubsection{\movingcode{ObjectInstance}}

An \code{ObjectInstance} is initialized with the following signature:

\begin{lstlisting}
ObjectInstance.new(runtime, klass)
\end{lstlisting}

All \code{Carat::Data} objects hold a reference to the runtime they exist in. The \code{klass} parameter is for an object representing the class of the instance (this spelling is used to avoid conflicts with the Ruby method \code{class}). When initialized, an \code{ObjectInstance} is assigned a unique numeric identifier.

Each object has a hash of \defn{instance variables} mapping of their names to values.

Objects can have \defn{singleton methods}. These methods are specific to individual instances, so if there are two objects of the same class, \code{a} and \code{b}, and \code{a} defines a singleton method, \code{b} will not have that method.

Objects don't store their own singleton methods. Instead, a \defn{singleton class} is created when first required, and the object's original class becomes the superclass of the singleton class (figure \ref{fig:singleton_class_creation}). This ensures the object can still access methods defined by its original class.

\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=15mm,
                    every edge/.append style={->},
                    every node/.style={minimum width=10mm}]

\begin{scope}[yshift=1cm]
\node[object]                (obj)   {apple};
\node[class,right=of obj]    (class) {Apple}
  edge [<-] node[auto,swap] {klass} (obj);
\node[class,above=of class]  (dots)  {...}
  edge [<-] node[auto,swap] {super} (class);
\end{scope}

\begin{scope}[xshift=8cm]
\node[object]                 (obj')    {apple};
\node[sclass,right=of obj']    (sclass') {apple'}
  edge [<-] node[auto,swap] {klass} (obj');
\node[class,above=of sclass'] (class')  {Apple}
  edge [<-] node[auto,swap] {super} (sclass');
\node[class,above=of class']  (dots')  {...}
  edge [<-] node[auto,swap] {super} (class');
\end{scope}

\begin{pgfonlayer}{background}
  \node (r1) [background,fit=(obj)(class)(dots)] {};
  \node (r2) [background,fit=(obj')(class')(sclass')(dots')] {};
\end{pgfonlayer}

\draw [diagram transition] (r1) -- (r2) node {Singleton class created};
\end{tikzpicture}
\caption{Singleton class creation}
\label{fig:singleton_class_creation}
\end{center}
\end{figure}

It is useful to be able to identify the class from which an object was created, but calling \code{klass} might return a singleton class instead. So objects have a \code{real_klass} method which returns the first \code{klass} or superclass of \code{klass} which is not a singleton class.

\subsubsection{\movingcode{ModuleInstance}}

A module is a container of methods. It cannot be instantiated, but it can be included within classes. A \code{ModuleInstance} is initialized with the following signature:

\begin{lstlisting}
ModuleInstance.new(runtime, klass, name = nil)
\end{lstlisting}

A \code{ModuleInstance} has a \defn{method table}, which maps method names to \code{Method} objects.

Being a type of object, a module can have singleton methods which are analogous to ``class methods" in other languages. Unlike normal objects, modules create their singleton class immediately rather than waiting for it to be needed.

\subsubsection{\movingcode{ClassInstance}}

A class is like a module, but can be instantiated. A \code{ClassInstance} is initialized with the following signature:

\begin{lstlisting}
ClassInstance.new(runtime, klass, superclass, name = nil)
\end{lstlisting}

Classes have a \defn{super} pointer, which is initially set to the \code{superclass} provided. But in general, the \code{super} may be either an include class or a normal class (see \ref{sec:module_inclusion}); the \code{superclass} method returns the first object in the \code{super} hierarchy which is a normal class.

Singleton classes are created in a slightly different way than for normal objects because the inheritance hierarchy needs to be respected for ``class methods" as well as instance methods. When a class creates its singleton class, it uses the singleton class of its superclass as the superclass of its singleton class. In this way, classes and their singleton classes are positioned in parallel (figure \ref{fig:singleton_class_inheritance}).

\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=15mm,
                    every edge/.append style={->},
                    every node/.style={minimum width=10mm}]
\node[class] (square) {Square};
\node[sclass,right=of square] (square') {Square'}
  edge [<-] node[auto,swap] {klass} (square);

\node[class,above=of square] (shape) {Shape}
  edge [<-] node[auto] {super} (square);
\node[sclass,above=of square'] (shape') {Shape'}
  edge [<-] node[auto,swap] {super} (square')
  edge [<-] node[auto,swap] {klass} (shape);

\node[class,above=of shape] (dots) {...}
  edge [<-] node[auto] {super} (shape);
\node[sclass,above=of shape'] (dots') {...}
  edge [<-] node[auto,swap] {super} (shape');

\begin{pgfonlayer}{background}
  \node [background,fit=(square)(square')(dots)(dots')] {};
\end{pgfonlayer}

\end{tikzpicture}
\caption{Singleton classes reflecting inheritance hierarchy}
\label{fig:singleton_class_inheritance}
\end{center}
\end{figure}

\subsubsection{Four Core Classes}

The most important four classes in the language are \code{Object}, \code{Module}, \code{Class} and \code{SingletonClass}. Their relationships are somewhat complex, but can be summarised by some basic rules:

\begin{enumerate}
  \item For \textit{all classes except \code{Object}}, the superclass of the singleton class is the singleton class of the superclass (as explained above)
  \item \code{Object} does not have a superclass, but its singleton class must have one because otherwise the property that ``everything is an object" would be violated. Intuitively, the real class of any class must be \code{Class}, so this must be the superclass of \code{Object}'s singleton class.
  \item The class of \textit{any} singleton class is \code{SingletonClass}.
\end{enumerate}

The core classes and their relationships are constructed by \code{KernelLoader}. They are shown in figure \ref{fig:core_relationships}.

\begin{figure}
\begin{center}
\begin{tikzpicture}
[
  every path/.append style={->},
  class/.append style={minimum width=20mm},
  sclass/.append style={minimum width=20mm},
  point/.style={coordinate}
]

\matrix (matrix)
  [row sep=15mm]
  {
    &[5mm]
    \node (nil) {\textbf{nil}};
    &[20mm]
    &[20mm]
    &[5mm] \\
    
    &
    \node[class] (Object) {Object}; &
    \node[sclass] (Object') {Object'}; &
    \node[point] (p23) {}; &
    \node[point] (p24) {}; \\
    
    &
    \node[class] (Module) {Module}; &
    \node[sclass] (Module') {Module'}; &
    \node[point] (p33) {}; &
    & \\
    
    \node[point] (p40) {}; &
    \node[class] (Class) {Class}; &
    \node[sclass] (Class') {Class'}; &
    \node[point] (p43) {}; &
    & \\
    
    &
    \node[class,multiline node] (SingletonClass) {Singleton\\Class}; &
    \node[sclass,multiline node] (SingletonClass') {Singleton\\Class'}; &
    \node[point] (p53) {}; &
    & \\[-10mm]
    
    &
    \node[point] (p61) {}; &
    \node[point] (p62) {}; &
    \node[point] (p63) {}; &
    & \\[-10mm]
    
    \node[point] (p70) {}; &
    \node[point] (p71) {}; &
    &
    &
    \node[point] (p74) {}; & \\
  };

\draw (Object) -- node[right] {super} (nil);
\draw (Module) -- node[right] {super} (Object);
\draw (Class) -- node[right] {super} (Module);
\draw (SingletonClass) -- node[right] {super} (Class);

\draw (Object') -- ($(Object') + (0,10mm)$) -- node[above] {super} ($(p24) + (0,10mm)$) --
      (p74) -- (p70) -- ($(p40) - (0,10mm)$) -- ($(Class) - (5mm,10mm)$) -- ($(Class.south) - (5mm,0)$);

\draw (Module') -- node[right] {super} (Object');
\draw (Class') -- node[right] {super} (Module');
\draw (SingletonClass') -- node[right] {super} (Class');

\draw (Object) -- node[above] {klass} (Object');
\draw (Module) -- node[above] {klass} (Module');
\draw (Class) -- node[above] {klass} (Class');
\draw (SingletonClass) -- node[above] {klass} (SingletonClass');

\draw (Object') -- node[above] {klass} (p23) -- (p63) -- (p61) -- (SingletonClass);
\draw (Module') -- node[above] {klass} (p33);
\draw (Class') -- node[above] {klass} (p43);
\draw (SingletonClass') -- node[above] {klass} (p53);

\begin{pgfonlayer}{background}
  \node [background,fit=(matrix)] {};
\end{pgfonlayer}

\end{tikzpicture}
\caption{Class and superclass relationships between the four core classes and their singleton classes}
\label{fig:core_relationships}
\end{center}
\end{figure}

\subsection{Continuation Passing Style}

The interpreter works out the result of a program by ``walking" the AST. An AST node with children probably needs to evaluate its child nodes before it can return its own answer. The obvious way to do this is to literally evaluate the children by calling the relevant evaluation methods, and then compute the answer to return.

This problem with this approach is it does not allow for ``jumps". Jumps occur when the program needs to move to a different node in the AST without first returning the answer of the current node. This can happen when a return call or an exception is encountered. The problem is that the execution of the AST is intrinsically linked to the stack of the implementation language, which can't be directly manipulated.

To solve this, the interepreter is written in \defn{continuation passing style} (CPS). Any method involved in the evaluation of AST nodes expects to be called with a \defn{continuation}. Abstractly, this is an object which represents the computation still to be done once an answer has been found. In this implementation, continuations are represented as lambdas, which expect one argument: the current result.

Some AST nodes can return a result immediately, without further computation (such as the literal \code{Nil} node). In this case, the node should simply call the continuation, passing its immediate value as the argument.

Most nodes need to evaluate other nodes before they can produce an answer. In this case, instead of evaluating a given child node and waiting for the answer, they evaluate the child node and pass a continuation which captures what needs to be done with the answer. This way, nodes have a choice about whether to continue a computation by calling the continuation, or by calling some other continuation which jumps to another part of the program. The difference is illustrated in the following psuedocode:

\begin{lstlisting}[title={\textbf{Without CPS}}]
def eval
  child_value = eval(child_node)
  compute_value(child_value)
end
\end{lstlisting}

\begin{lstlisting}[title={\textbf{With CPS}}]
def eval(&continuation)
  eval(child_node) do |child_value|
    yield compute_value(child_value)
  end
end
\end{lstlisting}

\subsection{Execution}

An AST is executed by passing its root node to \code{Runtime#execute}:

\begin{lstlisting}
def execute(root, scope = nil)
  with_stack { call_main_method(root, scope) }
end
\end{lstlisting}

Roughly speaking, the following happens:

\begin{enumerate}
  \item A new stack is pushed onto the stack of stacks
  \item The root node is wrapped in a special ``\code{main}" method, which is called
  \item The stack is removed from the stack of stacks
\end{enumerate}

\subsubsection{Trampoline}

\code{Runtime#with_stack} is defined as follows:

\begin{minipage}{\textwidth}
\begin{lstlisting}
def with_stack(&result)
  @stack_of_stacks << Stack.new
  result = result.call while result.is_a?(Proc)
  @stack_of_stacks.pop
  result
end
\end{lstlisting}
\end{minipage}

One outcome of CPS is that all evaluation methods have calls to other evaluation methods in \defn{tail position}: the last line of the method. When a method call in tail position returns, no further computation is done before the method which made the call also returns. Languages with \defn{tail call optimisation} keep the stack size down by replacing the calling method on the stack with the method which is being called in tail position. Ruby does not implement tail call optimisation, so it is quite easy to write a Carat program which will exhaust the stack space. This is because in CPS, no evaluation method returns a result until the very last node is evaluated.

To solve this, \code{with_stack} uses a \defn{trampoline}. In certain places where an evaluation method would usually call another evaluation method, it instead wraps that call in a lambda which is returned. This causes the stack in the implementation language to ``collapse" right back down to \code{with_stack}, which simply calls the lambda to resume execution. The \code{while} loop does this repeatedly until an answer which is not a lambda is returned.

\subsubsection{The main method}

The main method call is constructed like so:

\begin{minipage}{\textwidth}
\begin{lstlisting}
def call_main_method(contents, scope = nil)
  call  = MainMethodCall.new(contents.location)
  frame = Frame.new(scope || main_scope, call, default_failure_continuation)
  
  contents.runtime = self
  contents.eval_in_frame(frame, &identity_continuation)
end
\end{lstlisting}
\end{minipage}

If no scope is given, an initial one is created. Every \code{Scope} must have a value for \code{self}, which is used when looking up instance variables and evaluating method calls with no explicit receiver. In the main method, \code{self} is an instance of \code{Object} by default.

A special \code{MainMethodCall} object is also created. This is just so the main method call is present on the stack and can be used when exceptions generate a backtrace.

An initial frame is created using the scope, call and default failure continuation. The AST node's \code{eval_in_frame} method is called, which adds the frame to the stack, evaluates the node, and then ensures the frame is subsequently removed from the stack. The continuation given does nothing with the final answer, because the end of the program has been reached.

\subsection{Sequential evaluation}

Returning to the example, the top node is an expression list. Expression list nodes contain an array of child nodes, which are evaluated in turn. The result of the last node is the result of the expression list.

This presents a challenge, because whilst the natural inclination would be to loop over the child nodes, CPS requires that evaluation calls only appear in tail position. To solve this, \code{Runtime} provides two high-level operations, \code{each} (for iteration) and \code{fold} (for accumulation). These translate a sequential operation on an array into a recursive one using continuations. For AST nodes, there is also \code{eval_fold} which accumulates the result of evaluating each node in an array.

\subsection{Method calls}

The only item in the expression list is a \code{MethodCall[:puts]} with no receiver and an argument list containing ``Goodbye Cruel World". Method calls are evaluated as follows:

\begin{enumerate}
  \item Evaluate the receiver. If there is no explicit receiver, the \code{self} object in the current scope (the one at the top of the scope stack) is used.
  \item Ask the receiver object for the instance method with the given name. The advantage of the object model discussed in section \ref{sec:object_model} is that method look-up is very simple. When an object looks for an instance method, it asks its \code{klass} to look up that method. If the class contains the method in its method table, it returns it. Otherwise, it asks its \code{super}. Eventually, when there is no \code{super} (i.e. for \code{Object}), no method has been found so \code{nil} is returned.
  \item If the method is found, call the receiver object's \code{call} method which creates a \code{Call} object and ``sends" it.
  \item If the method is not found, raise an exception (see section ?)
\end{enumerate}

The following attributes of a \code{Call} object are worth explaining:

\begin{enumerate}
  \item The \defn{callable} is the method or lambda being called.
  \item The \defn{scope} is the scope which the callable should be evaluated within. For method calls, this starts as an empty scope where \code{self} is the receiver object.
  \item The \defn{caller scope} is the scope from which the call was made. (The current scope of the runtime when the \code{Call} was created.)
  \item The \defn{argument list} is the \code{ArgumentList} AST node represting the arguments passed to the call. (It can also be an array of objects, for convenience when making calls within the implementation language.)
  \item The \defn{continuation} describes the computation to be done once the call has been sent.
\end{enumerate}

The following happens when a call is sent:

\begin{enumerate}
  \item A frame containing the call and its scope is pushed onto the stack
  \item The argument list is evaluated to produce the argument values
  \item The argument values are matched to the argument pattern of the callable and assigned (see section ? for a detailed explanation)
  \item The callable's contents are evaluated
\end{enumerate}

This is one of the key places where a lambda is used to return to the trampoline method.

\subsection{Module inclusion}
\label{sec:module_inclusion}

In the example, \code{self} is an \code{Object} instance. \code{Object} does not have a \code{puts} method, but it includes the \code{Kernel} module, which does.

As explained above, the only way methods are found is by walking up the \code{super} chain. So when a module is included within a class, it must be inserted somewhere in the \code{super} chain. If inserted directly, the module's \code{super} would need to take the original value of the \code{super} of the object including the module. This would be problematic if the module was included more than once.

Instead, an \defn{include class} is created and the actual module's \code{super} is unchanged. The method table of an include class is a direct reference to the method table of the module it represents. Similarly, another include class becomes the \code{super} of the singleton class, linking to the module's singleton class. Module inclusion is shown in figure \ref{fig:module_inclusion}.

\begin{figure}
\begin{center}

\tikzset{
  module inclusion diagram/.style={
    node distance=15mm,
    every edge/.append style={->},
    every node/.style={minimum width=10mm},
    split node/.style={
      rectangle split,
      rectangle split parts=2,
      rectangle split part align={left, left}
    },
    class/.append style={split node},
    sclass/.append style={split node},
    module/.append style={split node},
    remember picture
  }
}

\begin{tikzpicture}[module inclusion diagram]

\node[module] (Quackable) {\textbf{Quackable} \nodepart{two} method\_table};
\node[sclass,right=of Quackable] (Quackable') {\textbf{Quackable'} \nodepart{two} method\_table};
\node[class,above=of Quackable] (Duck) {\textbf{Duck} \nodepart{two} method\_table};
\node[sclass,right=of Duck] (Duck') {\textbf{Duck'} \nodepart{two} method\_table};
\node[class,above=of Duck] (Object) {\textbf{Object} \nodepart{two} method\_table};
\node[sclass,right=of Object] (Object') {\textbf{Object'} \nodepart{two} method\_table};

\draw[->] (Duck) -- node[auto,swap] {super} (Object);
\draw[->] (Duck') -- node[auto,swap] {super} (Object');
\draw[->] (Duck) -- node[auto] {klass} (Duck');
\draw[->] (Object) -- node[auto] {klass} (Object');

\draw[->] (Quackable) -- node[auto] {klass} (Quackable');

\begin{pgfonlayer}{background}
  \node (r1) [background,fit=(Object)(Quackable')] {};
\end{pgfonlayer}

\end{tikzpicture}

\vspace{3cm}

\begin{tikzpicture}[module inclusion diagram]

\node[class] (Object2) {\textbf{Object} \nodepart{two} method\_table};
\node[sclass,right=30mm of Object2] (Object2') {\textbf{Object'} \nodepart{two} method\_table};
\node[class,below=30mm of Object2] (Include2) {\textbf{\textit{IncludeClass}} \nodepart{two} method\_table};
\node[class,below=30mm of Object2'] (Include2') {\textbf{\textit{IncludeClass}} \nodepart{two} method\_table};
\node[class,below=of Include2] (Duck2) {\textbf{Duck} \nodepart{two} method\_table};
\node[sclass,below=of Include2'] (Duck2') {\textbf{Duck'} \nodepart{two} method\_table};

\node[module,above right=5mm and 6mm of Include2] (Quackable2) {\textbf{Quackable} \nodepart{two} method\_table};
\node[sclass,right=30mm of Quackable2] (Quackable2') {\textbf{Quackable'} \nodepart{two} method\_table};

\draw[->] (Duck2) -- node[auto,swap] {super} (Include2);
\draw[->] (Duck2') -- node[auto,swap] {super} (Include2');
\draw[->] (Include2) -- node[auto,near end,swap] {super} (Object2);
\draw[->] (Include2') -- node[auto,near end,swap] {super} (Object2');

\draw[->] (Duck2) -- node[auto] {klass} (Duck2');
\draw[->] (Object2) -- node[auto] {klass} (Object2');

\draw[->] (Quackable2) -- node[near end,auto] {klass} (Quackable2');

\draw[->,dashed] (Include2.two east) -- ++(3mm,0) -- ($(Quackable2.two west) - (3mm,0)$) -- (Quackable2.two west);
\draw[->,dashed] (Include2'.two east) -- ++(3mm,0) -- ($(Quackable2'.two west) - (3mm,0)$) -- (Quackable2'.two west);

\begin{pgfonlayer}{background}
  \node (r2) [background,fit=(Object2)(Duck2)(Quackable2')] {};
\end{pgfonlayer}
\end{tikzpicture}

\begin{tikzpicture}[overlay,remember picture]
  \draw [diagram transition] (r1) -- (r2)
    node[near end,draw=black!15,solid,text width=2cm,fill=black!3,inner sep=2mm] {\code{Quackable} included in \code{Duck}};
\end{tikzpicture}

\caption{Module inclusion}
\label{fig:module_inclusion}
\end{center}
\end{figure}

\subsection{Primitives}

The method definition for \code{Kernel#puts} (in \path{kernel/kernel.carat}) is:

\begin{lstlisting}
def puts(obj = "\n")
  Primitive.puts(obj)
end
\end{lstlisting}

This is a \defn{primitive method call}. Primitives are the eventual way that a program can actually ``do" something; everything else is just memory access and method calls. In this case, the \code{puts} method needs to output some text, so it uses the \code{puts} primitive.

The \code{Primitive} class is represented by \code{Carat::Data::PrimitiveClass} in the implementation language. The primitive syntax is parsed in exactly the same way as any other method call, but \code{Primitive}\-\code{Class} overrides two methods from \code{ObjectInstance}:

\begin{enumerate}
  \item \textbf{\code{lookup_instance_method}}: Instead of returning a \code{MethodInstance} found in the klass' method table, it prepends ``\code{primitive_}" to the method name and finds an implementation language method for the current object with that name
  
  \item \textbf{\code{create_call}}: Instead of returning a \code{Call}, it returns a \code{PrimitiveCall}
\end{enumerate}

\code{PrimitiveCall#send} then evaluates the arguments in the standard way, and calls the implementation language method which provides the primitive behaviour.

For the example, \code{self} is an \code{Object}, but the method is in \code{Kernel}. The \code{primitive_puts} method is actually defined the \code{Carat::Data::KernelModule} module. When a module inclusion happens in the target language, the primitive checks whether there is a corresponding module in the implementation language. If so, that module is included in the implementation language. For example, when \code{Object} includes \code{Kernel} in the target language, \code{ObjectInstance} includes \code{KernelModule} in the implementation language.

When \code{KernelModule#primitive_puts} is finally called, it converts the object given as an argument to a Ruby string and uses Ruby's \code{Kernel.puts} method to output it.
